- K8s https://s3rius.blog/start-with-k8s
- КОРУТИНЫ https://pavel-karateev.gitbook.io/intermediate-python/struktury-dannykh/coroutines
- GIL https://www.youtube.com/watch?v=AWX4JnAnjBE

## Python:

- Типы данных
  - int, float, str, bool, list, set, frozenset, dict, tuple, bytes, bytearray, complex
  - Изменяемые:
    - list, dict, set, byte array
  - Неизменяемые:
    - int, float, complex, string, tuple, frozenset (неизменяемая версия set), bytes
- Хэш функции
  - Хэш-функция - это функция, которая принимает на вход какие-либо данные (например, строки) и возвращает число по некоторому заданному алгоритму. 
  - Назначением хэш-функций является возможность помещения некоторого элемента (например, строки) в хэш-таблицу, на основе которых реализованы, например, словари и множества в Python.
- на основании какой структуры данных реализованный Словари?
  - Hash таблицы. Ключами могут быть только Immutable типы данных, чтобы можно было взять hash.
  - Сейчас в питоне сохраняется последовательность данных в словаре, (с Python 3.9)
- Коллизия что такое?
  - hash берущийся от двух разных значений - идентичен.
  - При поиске элемента, если находится два идентичных Hash'a, то сравниваются значения. Если не совпало, то берется следующий.
- Методы решения коллизий(открытой адресации и цепочек) [link](http://genius.pstu.ru/file.php/1/pupils_works_2017/MuhinaAlisa.pdf)
  - если хэш функция идеальна, то коллизии не будет
  - метод адресации открытой, когда идем дальше и пытаемся найти пустой слот для записи элемента. ! иногда придется пройти циклически начиная с самого первого элемента и до того что вызвало коллизию. (будут проблемы с вставкой, так как много мест будет занято, а скучковавшиеся элементы будут превращаться в некий кластер)
  - метод цепочек - В позиции номер i хранится указатель на голову списка тех элементов, у которых хеш-значение ключа равно i; если таких элементов в множестве нет, в позиции i записан NULL.
- Декораторы
  - Вносит дополнительную функциональность, не изменяя основную логику
  - Реализовать можно через функцию или класс `__call__` и `__init__` переопределить:)
- Генераторы (yield)
  - Генератор — это объект, который сразу при создании не вычисляет значения всех своих элементов
  - Он хранит в памяти только последний вычисленный элемент, правило перехода к следующему и условие, при котором выполнение прерывается
  - Вычисление следующего значения происходит лишь при выполнении метода next(). Предыдущее значение при этом теряется
- Итераторы
  - обьект, имеющий метод `__next__`
- Чем отличается Генератор от Итератора?
  - генератор в отличие от итератора не хранит все элементы последовательности в памяти. 
  - Генератор - частный случай итератора (но не наоборот)
- Корутины
  - Корутины похожи на генераторы за исключением нескольких отличий, основные из которых:
    - генераторы возвращают данные
    - корутины потребляют данные
  - ```python
    def function():
    while True:
        line = (yield)
        print(line)
    ```
- GIL
  - f
- Асинхронность event loop
  - f
- Теорию по асинхронности и asyncio.
  - ``asyncio`` — это библиотека для написания конкурентного кода с использованием синтаксиса async/await.
  - https://digitology.tech/docs/python_3/library/asyncio.html


## Django
- queryset
  - ленивый. Его можно создавать, фильтровать и вообще передавать без фактического обращения к базе данных. 
  - Никаких запросов к бд не будет, пока не сделать что то для его вычисления.
    - Итерация по нему
    - Асинхронная итерация
    - обернуть в list()
    - pickle
    - caching
    - slicing
    - Обернуть в len()
    - Обернуть в repr()
- когда именно совершаются запросы к бд в джанге
- 

По сути будут производиться Join'ы, засчет которых ORM сделает меньше запросов к БД.
- select_related 
  - `select_related` для `ForeignKey`, `OneToOne` (когда обьект один). Позволяет нам точно указать Django, какие связанные модели мы хотим, чтобы он мог заранее выполнить JOINs
- prefetch_related
  - `prefetch_related` для `ManyToMany`. 
- Prefetch
  - В некоторых сценариях простого синтаксиса `prefetch_related` недостаточно, чтобы Django не выполнял дополнительные запросы. Для большего контроля предварительной выборки вы можете использовать объект предварительной выборки `Prefetch`
- Оптимизация запросов бд
  - кэширование id, для получения их для FK (в джанге вроде как поумолчанию)
  - select_related, prefetch_related, Prefetch, чтобы получить все в 1 запросе (для prefetch_related - 2)
  - накидывание индексации (но тут аккуратно надо, а то много проблем повлечет за собой, например вставка)
  - кэширование постоянных запросов.
  - убирание ненужных полей из запроса (не select *, а перечисляем что нужно)
  - для просмотра запросов можно глянуть Explain
  - ``Entry.objects.all().iterator()`` итератор чтобы не грузить все обьекты в память при ``.all()``
  - aggregation
  - F
  - не сортировать результаты, если нет нужды
  - использование count() и exist() для проверки наличия и подсчета обьектов
  - ``bulk_create()`` для массового создания, но с ним надо быть аккуратней, сигналы некоторые не отсылаются при таком подходе.
  - ``values()``, ``values_list()`` для представления данных в виде массива
  - ``defer()``, ``only()`` если нам нужны определенные поля в queryset'е.
 
## БД
- индексация
  - f
- Какие бывают индексы, как работают, виды и отличия
  - f
- Where
  - f 
- Like
  - f
- Having
  - f
- Acid
  - набор требований к транзакциям в системе. Атомарность, согласованность, изоляция, устойчивость.
  - Атомарность - никакая транзакция не будет зафиксирована в системе частично
  - Согласованность - каждая успешная транзакция по определению фиксирует только допустимые результаты
  - Изоляция - параллельные транзакции не должны оказывать влияние на результат другой транзакции
  - Устойчивость - если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.
- Транзакции
  - это операции которые либо полностью завершены, либо если один из этапов упал - откатываются все предыдущие (либо операции все полностью не завершены).
- Уровни изоляции транзакций
  - Read uncommitted
    - решает Потерянное обновление
    - блокируем данные на запись и две параллельные транзакции - последовательно выполнятся
  - Read Committed
    - решает Грязное чтение
    - когда одна транзакция завершилась и изменила данные, а вторая транзакция все еще работает со старыми
    - можно блокировать изменяемые данные для читающих транзакций до завершения изменяющей транзакции
    - или можно хранить две версии параллельно изменяемых строк
    - - блокировка на запись работает до конца отдельной операции
  - Repeatable read
    - решает Неповторяющееся чтение
    - Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена.
    - блокировка на запись работает до конца транзакции, а не отдельной операции
  - Serializable
    - решает Фантомное чтение
    - Самый высокий уровень изолированности
    - Транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует.
    - обеспечивается блокировкой и на запись, и на чтение любого блока данных, с которым мы работаем.
- Проблемы транзакций?
  - Потерянное обновление
    - Когда несколько транзакций что-то обновили в БД, но по итогам результат такой, будто отработала лишь часть транзакций.
    - полное отсутствие изоляции транзакций
  - Грязное чтение
    - Когда ваша транзакция может прочитать данные, которые были добавлены/изменены другой транзакцией, пока та ещё не вызвала COMMIT этих данных (ещё другая транзакция могла что-то удалить, тогда ваша транзакция перестанет это видеть).
  - Неповторяющееся чтение
    - Когда одинаковый запрос в одной транзакции может вернуть разные данные
  - Фантомное чтение
    - Когда: одинаковый запрос может вернуть НОВЫЕ строки, которые были закомичены из другой транзакции.
- Нормализация баз данных
  - это процесс организации данных в базе данных, включающий создание таблиц и установление отношений между ними в соответствии с правилами, которые обеспечивают защиту данных и делают базу данных более гибкой, устраняя избыточность и несогласованные зависимости.
- Методы оптимизации баз данных. [VIDEO](https://www.youtube.com/watch?v=9yWZ-LIsAII)
  - подзапросы
  - покрывающий индекс
- Шардирование
  - f


## Tools
- Вопросы по redis rabitmq
- по редису спрашивал принцип применения и типы данных которые бд поддерживает
- Pytest 
- Celery (shared task)
- K8s

## Архитектура
- Solid
- Kiss
- Dry
- Acid
- ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ (какие знаешь как и для чего применяются)

## FAST API
- Fast api - dependency injection https://fastapi.tiangolo.com/tutorial/dependencies/
- events FastAPi https://fastapi.tiangolo.com/advanced/events/

* Теорию по асинхронности и asyncio.
* Чистый SQL.
* Методы оптимизации баз данных.
* Названия шаблонов проектирования (Как они строятся он знает, а названия путает).
* По джанго надо именно теоретическую часть подлатать. Так как запросы писать умеет, проблемы в них тоже нашёл сразу. А в теории просадка.

