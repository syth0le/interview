# Python middle #3

- инкапсуляция.
  - В Python нет

- Чем отличается модуль от пакета в Python?
  - Модуль- файл
  - Пакет - с init.py файлом, набор модулей или набор других пакетов

- Что такое наследование?
- Как работает в Python?
  - MRO2 - когда наслежуемся от 2ух классов, то по цепочке сначала у левого идем вверх, затем справа. Минус в том, что все обьекты наследуются от object, и в MRO2 мы можем дойти до него с левой стороны, найдя какой то метод у этого object’a, хотя он мог быть у первого же класса родителя по цепочке справа.
  - В MRO3 теперь у обоих родителей мы поднимаемся ровно на 1 уровень, не доходя до конца цепочки.

- Как в Python работает сокрытие методов и атрибутов?
  1. Без ничего - публичный
  2. _ - protected
  3. __ - private
  - Если обратимся к private методу, то получим ошибку, но обратиться все равно можно через _ у класса:
  _ClassName.__private()
  К protected можно обращаться в любом случае, единственное IDE будет подчеркивать что так нельзя.

- __…__() - магический метод. Зачем нужны?

- Исключения. Что знаешь?
  - Может быть несколько except:
  ``` python
    try:
        …
    except ZeroDivisionError:
        …
    except NoneError:
        …
  
  ```

  - Можем одновременно несколько исключений ловить в одном except
  - Есть блок finally который точно выполняется всегда
  - Есть else который выполнится если ни одно условие по отлову ошибки не сработало

- Comprehensions. С какими обьектами можно писать?
  - С итерируемыми

- Разница между рекурсией и итерацией?
  - Это совершенно разные понятия
  - Рекурсия оперирует функциями
  - Итерация - по порядку элементов какого то обьекта

- Недостатки рекурсии?
  - Иногда медленно работает
  - Надо заботиться об условиях выхода из рекурсии, чтобы не было вечной рекурсии.

- Что такое декоратор?
  - Вносит дополнительную функциональность, не изменяя основную логику
  - Реализовать можно через функцию или класс call и init переопределить:)

- Контекстный менеджер?
  - with - позволяет выполнить какой то блок кода гарантированно. Например закрытие файла или соединения. Чтобы не было утечек памяти и тд. Класс реализовать можно переопределив enter, exit.

- Метакласс?
  - Это класс создающий другие классы. Отвечает за создание других обьектов с какими то заготовленными параметрами ( например выставленными атрибутами)
  - Например в FastApi создание таблицы автоматом с именем класса.
  - Методологии разработки через тестирование?
    - TDD - сначала пишем тест, а потом логику
    - BDD
    - DDD - domain driven development

- JWT?
  - Это авторизация на основе OAUTH2.0. Клиент с токеном ходит к серваку и получает что нужно.

- Чем отличается JWT от Сессии?
  - Шифрование токена, чтобы нельзя было его подменить. В токене шифруют данные пользователя, чтобы на сервере идентифицировать его без запросов к БД. Там в токене три части, разделенные через точки. В каждой зашифрован email, login, какая то еще важная доп инфа, метаданные и тд.

- REST
  - Принцип клиент серверной архитектуры.
  - В Django - DRF, можно прикрутить swagger

- Какие ответы используют в REST и SOAP?
  - SOAP - xml - старый и тяжелый для чтения
  - REST - json, с крутой вложенностью, читабельностью и и ключ-значениями

- Принципиальное отличие REST от SOAP?
  - SOAP - точечный вызов какихто функций с произвольным числом параметров. Яркий пример этого - GraphQL
  - REST - формализует данные, можем получить список обьектов и затем знаем как получить один без документации, так как понимаем что все построено на понятии CRUD операций.

- Брокеры сообщений
  - Полноценный это Kafka, RabbitMQ.
  - Redis обычная очередь без стратегии.
  - Брокеры нужны для периодических и отложенных задач
  - Выполняют код как бы асинхронно, не нагружая основную систему( допустим отправка сообщений или выгрузка/загрузка каких то данных)

- Асинхронщина. Разница Async и параллельных вычислений?
  - Проблемы при параллельщине это GIL. Работает он стороне C. Предотвращает проблемы с работой двух потоков и обращениями к одной ячейке памяти. По сути это глобальный мьютекс. Он позволяет не беспокоится за эти проблемы.
  - Именно поэтому несколько потоков одновременно выполняться не могут GIL контролирует запуск потоков, не давая другим запуститься пока какой то работает. Еще мы не умеем контролировать завершение потока , именно пожтому разработчики сделали GIL неким менеджером, что контролирует именно запуск потоков новых.
  - Раньше потоки работали по тикам, и эти тики могли длиться слишком долго, что позволяло в одном тике итерироваться по n объектам массива. Эту проблему решили, создав стратегию - при которой 5 мс отводится на работу потока, затем он переключается на другой
  - Вообще мультипроцессность решает проблемы CPU bound . Проблемы мощности и способности вычислений, а многопоточность - IObound. Пока один поток ждет ответ от бд - второй работает.
  - Многие программисты используют нетривиальные вещи. Например RPython Ipython, исключая работу с GIL, так как Гил работает именно на стороне C, а не Python.
  - Есть еще проблема у мультипроцессности - дележка какими то данными. Это решается через Kafka какую нибудь или через сокеты. Идеальное решение для этого есть в Go - channels. Нужно это, чтобы запихать данные в канал и поделиться чем то с другими процессами.
  - У потоков все проще. Они делят память внутри одного процесса, у них общение и дележка данными совершенно иная и намного проще процессов.
  - А асинхронщина обычный event loop. Без менеджера переключений , это приводит к тому что может произойти переключение не на столь важные вещи. Плюс высока проблема работы под нагрузкой, так как время ожидания выполнения и переключения между одним действием и другим начинает возрастать. Поэтому не всегда асинхронный код работает быстрее синхронного.