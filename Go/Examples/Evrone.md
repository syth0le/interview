[HABR](https://habr.com/ru/articles/758662/#28)
1. Go — императивный или декларативный? А в чем разница?

Декларативный. В декларативном надо явно описывать что ты хочешь от программы для достижения цели. В императивном описываешь что ты хочешь получить без упоминания шагов что надо сделать.

2. Что такое type switch?

[Переключатель типов](https://tour.golang.org/methods/16) сравнивает типы, а не значения. В остальном он аналогичен переключателю выражений.

```go
switch v := i.(type) {
case T:
    // here v has type T
case S:
    // here v has type S
default:
    // no match; here v has the same type as i
}
```  

3. Как сообщить компилятору, что наш тип реализует интерфейс?

Если наш тип реализует все методы интерфейса, значит он реализует этот интерфейс. Утиная типизация. Если что то крякает как утка, бегает как утка, летает как утка - то это утка.

4. Как работает append?

Как работает Append: если capacity достаточно, базовый массив используется повторно. В противном случае выделяется новый базовый массив достаточной длины и данные копируются.

5. Какое у slice zero value? Какие операции над ним возможны?

Zero value у slice == nil  
Возможные операции: len, cap, append
- append([]string(nil), "") инициализирует slice пустым значением. != nil. len & cap == 1
- append([]string(nil), []string(nil)...) slice == nil, len & cap == 0
- range append([]string(nil), []string(nil)...) в range не войдет, т.к. размер слайса == 0

6. Как устроен тип map?

Map в Go это хэш таблица, позволяющая хранить пары ключ-значение и обладающая следующими функциями: маппинг, вставка, удаление, поиск. Map in Go не упорядоченная. 
Место поиска определяется рандомно. Когда мы пытаемся получить значение из мапы, а его там нет, получаем «нулевое значение типа», что в случае числа 0. 
Map — ссылочный тип и мало объявить переменную, надо ее проинициализировать.  
Buckets - хранилище пар ключ-значение. Если в каждом «ведре» в среднем более 6,5 элементов, происходит увеличение массива buckets.

[Вот тут](https://habr.com/ru/post/457728/) про мапы можно почитать подробнее на русском.
[А тут от Дэйва Чейни](https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics).

7. Каков порядок перебора map?

Случайным образом.

*Как получить одно случайное значение из map?*  
The only way to select a random key from a map is to put all the keys into a slice and then pick a random element from that slice. If you need the elements in a truly random order, use rand.Perm() to generate a random permutation of the array and process them in that order.


8, 9. Что будет, если читать из закрытого канала? Что будет, если писать в закрытый канал?

- A send to a nil channel blocks forever
- A receive from a nil channel blocks forever
- A send to a closed channel panics
- A receive from a closed channel returns the zero value immediately
- (еще что всегда писатель закрывает канал)
- (еще если  канал закрыт то отправка данных закончена)

Подробнее [в посте Дейва Чейни](https://dave.cheney.net/2014/03/19/channel-axioms).

Мы можем разделить приложение на множество конкурентных задач, которые могут выполняться с помощью различных горутин. Это предоставит возможность использовать конкурентности в приложении.  
Если приложение выполняется на нескольких ядрах, то добавляется и параллелизм.

Преимущества горутин:
- Они легковесны.
- Легко и без проблем масштабируют.
- Они — практически потоки.
- Требуют меньше памяти (2KB).
- Предоставляют дополнительную память горутинам во время выполнения.

[Как работают go-рутины](https://habr.com/ru/post/412715/)

[Конкурентность не параллелизм](https://medium.com/nuances-of-programming/%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%B8-%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D0%B8%D0%B7%D0%BC-%D0%B2-golang-go-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D1%8B-82bae0f92e81)

[Примитивы синхронизации в Go](https://nuancesprog.ru/p/5583/)

10. Как вы отсортируете массив структур по алфавиту по полю Name?
С помощью функции sort.SliceStable https://play.golang.org/p/gxTLdq-ZnzW
при сортировке слайса базовый массив также отсортируется
Доп. вопрос: конвертация array to slice
```go
var a [32]byte 
slice := a[:]
```

11. Что такое сериализация? Зачем она нужна?

Сериализация — это преобразование объекта или дерева объектов в какой-либо формат с тем, чтобы потом эти объекты можно было восстановить из этого формата. Используется, например, для сохранения состояния программы (то есть, некоторых её объектов) между запусками. Или для передачи данных между различными экземплярами программы (или различными программами), например, по сети.

Главная идея состоит в том, что сериализованный формат — набор байт или строка, которую можно легко сохранить на диск или передать другому процессу или, например, по сети, в отличие от самого объекта. А значит, задача сохранения объекта/группы объектов при этом сводится к простой задаче сохранения набора байт или строки.

JSON — один из популярных форматов для сериализации, он текстовый, легковесный и легко читается человеком.

12. Сколько времени в минутах займет у вас написание процедуры обращения односвязного списка?

10 минут. Вот решение https://play.golang.org/p/l2xTn7dTlen

13. Где следует поместить описание интерфейса: в пакете с реализацией или в пакете, где этот интерфейс используется? Почему?
    Наводящие вопросы: что такое tight coupling? Почему это плохо? В каком варианте связанность слабее?

Каждая библиотека не должна экспортировать интерфейс, и общее правило для определения того, кто должен создавать интерфейс можно описать так:  
*Интерфейс создается потребителем (consumer), а не продюсером (producer).*

- интерфейсы определяют поведение, статические типы — данные
- чем больше интерфейс, тем слабее абстракция
- интерфейс, как правило, создается потребителем.

14. Предположим, ваша функция должна возвращать детализированные Recoverable и Fatal ошибки. Как это реализовано в пакете net? Как это надо делать в современном Go?

Wrapper над ошибкой с каким-то своим функционалом.

15. Главный недостаток стандартного логгера?

Главным недостатком стандартного логгера в Go (пакет log) является его ограниченная функциональность по сравнению с более продвинутыми библиотеками логирования.
- ограничение настройки формата
- медленнее чем иные реализации (тот же zap очень быстр)
- нет асинхронного логгера
  - Асинхронный логгер работает по принципу отделения операций логирования от основного потока выполнения программы, что позволяет избегать задержек, вызванных I/O операциями, например, записью в файл или отправкой логов в сеть:
    - Логи сначала записываются в буфер (например, канал на Go), прежде чем они будут обработаны.
    - Один или несколько фоновых потоков (го-рутин в Go) извлекают сообщения из буфера и записывают их в назначенные цели (файлы, консоль, удаленные серверы и т. д.). Это отделяет обработку логов от их генерации.


16. Есть ли для Go хороший orm? Ответ обоснуйте.

пишем используя squirrel
у orm есть недостатки, например у django - странный lazy load, какие-то оптимизации. ORM - от M-manager, нет гибкости. 
+ возможно не все виды запросов можно написать

Что я хочу оценить: количество и качество усилий, которые кандидат приложил к выбору инструментов, ускоряющих и облегчающих повседневную деятельность.
Самый популярный неправильный ответ: «Gorm, вроде, неплох». Конкурирует с ответом «Я всё пишу руками». Я даже согласен с обоими ответами, но давайте обсудим подробнее — как устроен gorm, и почему вдруг руками.
Наводящие вопросы: что означает буква M в аббревиатуре ORM? Что на эту букву M есть в gorm? А что такое DAL и зачем он нужен?

17. Какой у вас любимый линтер?
[пример](https://github.com/golangci/awesome-go-linters)
gofmt
goimports


18. Можно ли использовать один и тот же буфер []byte в нескольких горутинах?
- да, можно безопасно использовать только для чтения, но если есть запись, то нужны мьютексы. (??)

19. Какие типы мьютексов предоставляет stdlib?
Мьютекс или семафор, как его обобщение (конкретно, объект (переменная), расположенный по некоторому адресу) это точка синхронизации потоков кода одного или (в некоторых случаях) нескольких процессов.
И ничего более. Он ничего не защищает. Ни объекты в памяти, ни участки кода.
Фактически поток кода, вызвавший операцию lock для указанного мьютекса увеличивает счетчик, связанный с этим мьютексом и продолжает выполнение если счетчик был равен нулю.

1. **sync.Mutex:**
    - Основной мьютекс для блокировки с примитивной функциональностью. Он предоставляет методы Lock для блокировки и Unlock для разблокировки.

2. **sync.RWMutex:**
    - Мьютекс с поддержкой разделяемой блокировки, что позволяет нескольким потокам читать данные одновременно, но только одному потоку писать. 
    - Он предоставляет дополнительные методы RLock и RUnlock для управления доступом на чтение.

20. Что такое lock-free структуры данных, и есть ли в Go такие?
Lock-free структуры данных — это структуры, которые позволяют нескольким потокам одновременно выполнять операции без использования блокировок, таких как мьютексы. 
Они обеспечивают безопасность многопоточной работы за счёт атомарных операций и позволяют избежать проблем, связанных с блокировками, таких как дедлоки.

atomic is a package that provides low-level atomic memory primitives useful for implementing synchronization algorithms. 
Atomic operations execute in constant time and are implemented in assembly language on supported platforms.

Наводящие вопросы: что такое atomic? А что такое sync.Map? Sync.Map — lockfree или нет?
Да, sync.Map в Go является lockfree, то есть не требует явной блокировки или механизмов синхронизации, таких как мьютексы.

<details>
cache contention
В коде sync.RWMutex можно увидеть, что при блокировке на чтение, каждая горутина атомарно обновляет счетчик readerCount. 
Когда ядро процессора обновляет счётчик, оно сбрасывает кеш для этого адреса в памяти для всех остальных ядер и объявляет, что владеет актуальным значением для адреса. 
Следующее ядро, прежде чем обновить счётчик, сначала вычитывает это значение из кеша другого ядра.

Передача между L2 кешем занимает ~ 40 нс. Когда много ядер одновременно пытаются обновить счётчик, то каждое становится в очередь и ждёт инвалидацию и вычитывание из кеша. 
Операция, которая должна укладываться в константное время внезапно становится O(N) по количеству ядер. Это и есть cache contention.

Для этой конкретной проблемы, когда у нас много ядер и система высоконагружена, можно использовать sync.Map вместо стандартной map с RWMutex. В остальных случаях sync.Map не нужен.

sync.Map оптимизирован для использования при частых чтениях и редких записях, что является обычной ситуацией в кэш-системах.

    <summary>
    Sync.Map в Go рекомендуется использовать в следующих случаях:
    
    При частых чтениях и редких записях. Это обычная ситуация в кэш-системах. 
    Когда несколько горутин читают, пишут и перезаписывают элементы для непересекающихся наборов ключей. 
    В таких случаях использование sync.Map может значительно снизить конкуренцию за блокировку по сравнению со стандартной картой Go в паре с отдельным мьютексом или RWMutex. 2
    </summary>
</details>

21. Способы поиска проблем производительности на проде?

Метрики, сбор логов, алерты и помощь профайлера

22. Стандартный набор метрик prometheus в Go -программе?

1. **Go runtime metrics:**
    - Эти метрики автоматически экспонируются библиотекой prometheus/client_golang через пакет prometheus/go_collector. Они содержат информацию о работе Go runtime:
        - go_goroutines: количество текущих активных горутин.
        - go_threads: количество текущих системных потоков, управляемых Go runtime.
        - go_memstats_alloc_bytes: размер объема динамической памяти, выделенной и активной.
        - go_memstats_heap_alloc_bytes: объем выделенной памяти на куче.

2. **Process metrics:**
    - Эти метрики экспонируются через пакет prometheus/process_collector и содержат информацию о процессе, такие как:
        - process_cpu_seconds_total: общее время CPU, использованное процессом.
        - process_resident_memory_bytes: объем памяти, резидентной в оперативной памяти.
        - process_virtual_memory_bytes: объем виртуальной памяти, используемой процессом.
        - process_start_time_seconds: время старта процесса в виде таймстампа Unix.


23. Как встроить стандартный профайлер в свое приложение?

Встроить стандартный профайлер в Go-приложение можно с помощью пакета net/http/pprof.
Этот пакет позволяет собирать профили CPU, памяти и других ресурсов.

И сделать админ апишку вот с таким набором ручек:
- http://localhost:6060/debug/pprof/ — общий доступ к профилированию.
- http://localhost:6060/debug/pprof/profile — профиль CPU.
- http://localhost:6060/debug/pprof/heap — профиль использования памяти.
- http://localhost:6060/debug/pprof/goroutine — профиль использования горутин.
- И другие профили, такие как блокировки или строковые профили.

24. Overhead от стандартного профайлера?

Низкий, так как профайлер семплирующий. Он собирает данные не постоянно, а периодически, делая снапшоты актуального состояния приложения и системы.
Поэтому его можно использовать и в проде.

25. Почему встраивание — не наследование?

Встраивание не является наследованием, потому что не подразумевает иерархию типов или полиморфизм, как в классическом наследовании.
Таким образом, встраивание — это скорее способ композиции, чем наследования. фокус идет на повторном использовании кода.
Наследование в ООП сосредотачивается на создании иерархий классов и полиморфном поведении
В го нет этого: **Объекты в программе должны быть заменяемыми экземплярами их базовых типов, не нарушая корректность программы.**

<details>
SOLID — это аббревиатура пяти основных принципов проектирования в объектно‑ориентированном программировании: 1

Single responsibility (SRP). Каждый класс должен иметь только одну причину для изменения. Это означает, что класс должен быть ответственным только за одну конкретную функцию или задачу.
Open-closed (OCP). Программные сущности, такие как классы, модули и функции, должны быть открыты для расширения, но закрыты для модификации. Вместо изменения существующего кода, следует добавлять новый код для внесения изменений.
Liskov substitution (LSP). Объекты в программе должны быть заменяемыми экземплярами их базовых типов, не нарушая корректность программы. 
Interface segregation.  Классы не должны зависеть от методов, которые они не используют. 
Dependency inversion (DIP). Классы не должны напрямую полагаться на другие классы, а вместо этого должны зависеть от абстракций.
</details>

26. Какие средства обобщенного программирования есть в Go?

Обобщенное программирование - Generics.

27. Какие технологические преимущества языка Go вы можете назвать?

- горутины, каналы
- очень крутая стандартная библиотека. По сути у программиста есть все, чтобы создать работоспособный проект.
- Сетевой ввод-вывод в Go реализован через модель асинхронного и неблокирующего I/O с помощью goroutine и многоплексирования событий. 
  - Это достигается через использование системных вызовов уровня операционной системы, таких как epoll на Linux или kqueue на macOS/BSD, под капотом Go runtime.

28. Какие технологические недостатки языка Go вы можете назвать?
Многие называют исключения - но это бред. Без них живется проще.
Как превратить []io.ReadWriter в []io.Reader?
- сложно привести слайс Структур к слайсу Интерфейсов, которому удовлетворяет структура.

29. **Как в Go устроен GC (Garbage Collector)**  
    https://habr.com/ru/post/265833/

30. **Отличие релиционных БД от NoSQL**  
    https://habr.com/ru/company/ruvds/blog/324936/

31. **Индексы в БД, как устроены и как работают.**  
    [Индексы в PostgreSQL](https://habr.com/ru/company/postgrespro/blog/326096/)